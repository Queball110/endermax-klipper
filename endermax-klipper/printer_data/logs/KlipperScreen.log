--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-10-29 16:53:22,668 [screen.py:main()] - Python version: 3.10
2023-10-29 16:53:22,668 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-10-29 16:53:22,676 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/orangepi/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.10/os.py", line 680, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/orangepi/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.10/os.py", line 680, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-10-29 16:53:22,871 [config.py:get_config_file_location()] - Passed config (-c): /home/orangepi/KlipperScreen.conf
2023-10-29 16:53:22,875 [config.py:__init__()] - Config path location: /home/orangepi/KlipperScreen/ks_includes/defaults.conf
2023-10-29 16:53:22,897 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-10-29 16:53:23,031 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-10-29 16:53:23,032 [config.py:install_language()] - Using system lang
2023-10-29 16:53:23,033 [config.py:install_language()] - Using lang en
2023-10-29 16:53:23,070 [screen.py:__init__()] - Screen resolution: 800x480
2023-10-29 16:53:23,073 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-10-29 16:53:23,755 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-10-29 16:53:23,773 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-10-29 16:53:23,787 [screen.py:initial_connection()] - Default printer: None
2023-10-29 16:53:23,787 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-10-29 16:53:23,788 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-10-29 16:53:23,890 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 16:53:23,906 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-10-29 16:53:23,937 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:53:23,959 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-10-29 16:53:23,961 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-10-29 16:53:23,979 [_logging.py:info()] - Websocket connected
2023-10-29 16:53:23,980 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-10-29 16:53:24,048 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:53:24,068 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:53:24,070 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 16:53:24,089 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 16:53:24,092 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 16:53:24,114 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 16:53:24,297 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 16:53:24,300 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '/home/orangepi/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>'}, 'printer': {'kinematics': 'none', 'max_velocity': '1000', 'max_accel': '1000'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/<your-mcu-id>', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '/home/orangepi/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'printer': {'max_velocity': 1000.0, 'max_accel': 1000.0, 'max_accel_to_decel': 500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'none'}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 16:53:24,303 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 16:53:24,303 [printer.py:reinit()] - # Extruders: 0
2023-10-29 16:53:24,304 [printer.py:reinit()] - # Temperature devices: 0
2023-10-29 16:53:24,304 [printer.py:reinit()] - # Fans: 0
2023-10-29 16:53:24,304 [printer.py:reinit()] - # Output pins: 0
2023-10-29 16:53:24,304 [printer.py:reinit()] - # Leds: 0
2023-10-29 16:53:24,330 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 16:53:24,333 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 16:53:24,562 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-10-29 16:53:24,570 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 16:53:24,571 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 16:53:24,577 [screen.py:init_printer()] - Printer initialized
2023-10-29 16:53:24,578 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-10-29 16:53:24,578 [printer.py:change_state()] - Adding callback for state: error
2023-10-29 16:53:24,587 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 16:53:24,679 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 16:57:17,250 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-10-29 16:57:17,251 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 16:57:17,252 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 16:57:17,255 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 16:57:17,344 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 16:57:20,964 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:57:20,995 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:57:20,999 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 16:57:21,029 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 16:57:21,032 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 16:57:21,067 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 16:57:21,217 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 16:57:21,220 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 16:57:21,221 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 16:57:21,221 [printer.py:reinit()] - # Extruders: 0
2023-10-29 16:57:21,222 [printer.py:reinit()] - # Temperature devices: 0
2023-10-29 16:57:21,222 [printer.py:reinit()] - # Fans: 0
2023-10-29 16:57:21,222 [printer.py:reinit()] - # Output pins: 0
2023-10-29 16:57:21,222 [printer.py:reinit()] - # Leds: 0
2023-10-29 16:57:21,246 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 16:57:21,248 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 16:57:21,471 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-10-29 16:57:21,473 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 16:57:21,473 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 16:57:21,475 [screen.py:init_printer()] - Printer initialized
2023-10-29 16:57:21,475 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-10-29 16:57:21,476 [printer.py:change_state()] - Adding callback for state: error
2023-10-29 16:57:21,486 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 16:57:21,578 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 16:57:48,829 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-10-29 16:57:48,830 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 16:57:48,832 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 16:57:48,838 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 16:57:48,994 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 16:57:51,963 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:57:51,994 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:57:51,997 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 16:57:52,020 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 16:57:52,023 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 16:57:52,051 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 16:57:52,279 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 16:57:52,282 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 16:57:52,283 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 16:57:52,284 [printer.py:reinit()] - # Extruders: 0
2023-10-29 16:57:52,284 [printer.py:reinit()] - # Temperature devices: 0
2023-10-29 16:57:52,284 [printer.py:reinit()] - # Fans: 0
2023-10-29 16:57:52,285 [printer.py:reinit()] - # Output pins: 0
2023-10-29 16:57:52,285 [printer.py:reinit()] - # Leds: 0
2023-10-29 16:57:52,315 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 16:57:52,317 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 16:57:52,540 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-10-29 16:57:52,543 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 16:57:52,543 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 16:57:52,545 [screen.py:init_printer()] - Printer initialized
2023-10-29 16:57:52,546 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-10-29 16:57:52,547 [printer.py:change_state()] - Adding callback for state: error
2023-10-29 16:57:52,551 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 16:57:52,660 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:00:07,996 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-10-29 17:00:07,998 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 17:00:08,002 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 17:00:08,008 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:00:08,146 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:00:10,952 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:00:10,975 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:00:10,977 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 17:00:10,997 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 17:00:11,000 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 17:00:11,703 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 17:00:11,750 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 17:00:11,755 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.550', 'pid_ki': '0.973', 'pid_kd': '167.673'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.249'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.463750, -0.100000, 0.260000, 0.607500\n-0.436250, -0.081250, 0.272500, 0.612500\n-0.450000, -0.093750, 0.258750, 0.621250\n-0.537500, -0.193750, 0.153750, 0.491250', 'x_count': '4', 'y_count': '4', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '87.80000000000001', 'max_x': '212.17000000000002', 'min_y': '77.3', 'max_y': '222.67'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.249, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.46375, -0.1, 0.26, 0.6075], [-0.43625, -0.08125, 0.2725, 0.6125], [-0.45, -0.09375, 0.25875, 0.62125], [-0.5375, -0.19375, 0.15375, 0.49125]], 'min_x': 87.80000000000001, 'max_x': 212.17000000000002, 'min_y': 77.3, 'max_y': 222.67, 'x_count': 4, 'y_count': 4, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.55, 'pid_ki': 0.973, 'pid_kd': 167.673, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 17:00:11,760 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 17:00:11,760 [printer.py:reinit()] - # Extruders: 1
2023-10-29 17:00:11,760 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 17:00:11,760 [printer.py:reinit()] - # Fans: 1
2023-10-29 17:00:11,761 [printer.py:reinit()] - # Output pins: 1
2023-10-29 17:00:11,761 [printer.py:reinit()] - # Leds: 1
2023-10-29 17:00:11,789 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 17:00:11,792 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 17:00:12,021 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 17:00:12,071 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:00:12,077 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-10-29 17:00:12,078 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 17:00:12,078 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 17:00:12,081 [screen.py:init_printer()] - Printer initialized
2023-10-29 17:00:12,082 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-10-29 17:00:12,082 [printer.py:change_state()] - Adding callback for state: startup
2023-10-29 17:00:13,997 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-10-29 17:00:13,998 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:00:14,003 [screen.py:_load_panel()] - Loading panel: main_menu
2023-10-29 17:00:14,311 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 17:00:14,325 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 17:00:14,338 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 17:00:14,351 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 17:00:14,420 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 17:00:14,424 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-10-29 17:00:16,962 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:00:17,013 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 17:00:17,051 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 17:00:17,054 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 17:07:30,977 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=800, height=480)
2023-10-29 17:07:54,433 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-10-29 17:07:54,434 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 17:07:54,436 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 17:07:54,447 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-10-29 17:07:54,449 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:07:54,562 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:07:57,949 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:07:57,969 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:07:57,971 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 17:07:57,990 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 17:07:57,992 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 17:07:58,014 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 17:07:58,048 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 17:07:58,052 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.249'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.463750, -0.100000, 0.260000, 0.607500\n-0.436250, -0.081250, 0.272500, 0.612500\n-0.450000, -0.093750, 0.258750, 0.621250\n-0.537500, -0.193750, 0.153750, 0.491250', 'x_count': '4', 'y_count': '4', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '87.80000000000001', 'max_x': '212.17000000000002', 'min_y': '77.3', 'max_y': '222.67'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.249, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.46375, -0.1, 0.26, 0.6075], [-0.43625, -0.08125, 0.2725, 0.6125], [-0.45, -0.09375, 0.25875, 0.62125], [-0.5375, -0.19375, 0.15375, 0.49125]], 'min_x': 87.80000000000001, 'max_x': 212.17000000000002, 'min_y': 77.3, 'max_y': 222.67, 'x_count': 4, 'y_count': 4, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 17:07:58,057 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 17:07:58,058 [printer.py:reinit()] - # Extruders: 1
2023-10-29 17:07:58,058 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 17:07:58,058 [printer.py:reinit()] - # Fans: 1
2023-10-29 17:07:58,059 [printer.py:reinit()] - # Output pins: 1
2023-10-29 17:07:58,059 [printer.py:reinit()] - # Leds: 1
2023-10-29 17:07:58,084 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 17:07:58,087 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 17:07:58,318 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 17:07:58,394 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:07:58,416 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 17:07:58,438 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 17:07:58,440 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 17:07:58,440 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 17:07:58,441 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 17:07:58,443 [screen.py:init_printer()] - Printer initialized
2023-10-29 17:07:58,444 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-10-29 17:07:58,444 [printer.py:change_state()] - Adding callback for state: startup
2023-10-29 17:07:59,290 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-10-29 17:07:59,291 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:07:59,297 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:07:59,449 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 17:07:59,464 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 17:07:59,477 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 17:07:59,491 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 17:07:59,567 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 17:11:09,646 [KlippyGtk.py:remove_dialog()] - Cannot remove dialog <Gtk.Dialog object at 0x7f86334f80 (GtkDialog at 0x556dd65120)>
2023-10-29 17:11:09,720 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=800, height=480)
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-10-29 16:17:15,829 [screen.py:main()] - Python version: 3.10
2023-10-29 16:17:15,830 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-10-29 16:17:15,841 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/orangepi/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.10/os.py", line 680, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/orangepi/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.10/os.py", line 680, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-10-29 16:17:16,120 [config.py:get_config_file_location()] - Passed config (-c): /home/orangepi/KlipperScreen.conf
2023-10-29 16:17:16,124 [config.py:__init__()] - Config path location: /home/orangepi/KlipperScreen/ks_includes/defaults.conf
2023-10-29 16:17:16,159 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-10-29 16:17:16,349 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-10-29 16:17:16,350 [config.py:install_language()] - Using system lang
2023-10-29 16:17:16,352 [config.py:install_language()] - Using lang en
2023-10-29 16:17:16,398 [screen.py:__init__()] - Screen resolution: 800x480
2023-10-29 16:17:16,400 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-10-29 16:17:17,216 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-10-29 16:17:17,234 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-10-29 16:17:17,249 [screen.py:initial_connection()] - Default printer: None
2023-10-29 16:17:17,249 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-10-29 16:17:17,250 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-10-29 16:17:17,355 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 16:17:17,375 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-10-29 16:17:17,414 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:17:17,436 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-10-29 16:17:17,439 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-10-29 16:17:17,455 [_logging.py:info()] - Websocket connected
2023-10-29 16:17:17,456 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-10-29 16:17:17,539 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:17:17,560 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 16:17:17,562 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: klipper primary_branch: main' contains an invalid value 'primary_branch:'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 16:17:17,565 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 klipper primary_branch:
 main' contains an invalid value 'primary_branch:
'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 16:17:17,599 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 16:17:17,601 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 16:17:17,630 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 16:17:17,849 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 16:17:17,853 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.249'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.463750, -0.100000, 0.260000, 0.607500\n-0.436250, -0.081250, 0.272500, 0.612500\n-0.450000, -0.093750, 0.258750, 0.621250\n-0.537500, -0.193750, 0.153750, 0.491250', 'x_count': '4', 'y_count': '4', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '87.80000000000001', 'max_x': '212.17000000000002', 'min_y': '77.3', 'max_y': '222.67'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.249, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.46375, -0.1, 0.26, 0.6075], [-0.43625, -0.08125, 0.2725, 0.6125], [-0.45, -0.09375, 0.25875, 0.62125], [-0.5375, -0.19375, 0.15375, 0.49125]], 'min_x': 87.80000000000001, 'max_x': 212.17000000000002, 'min_y': 77.3, 'max_y': 222.67, 'x_count': 4, 'y_count': 4, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 16:17:17,858 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 16:17:17,859 [printer.py:reinit()] - # Extruders: 1
2023-10-29 16:17:17,859 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 16:17:17,859 [printer.py:reinit()] - # Fans: 1
2023-10-29 16:17:17,859 [printer.py:reinit()] - # Output pins: 1
2023-10-29 16:17:17,860 [printer.py:reinit()] - # Leds: 1
2023-10-29 16:17:17,894 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 16:17:17,897 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 16:17:18,109 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 16:17:18,134 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 16:17:18,160 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 16:17:18,184 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 16:17:18,186 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 16:17:18,187 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 16:17:18,188 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 16:17:18,191 [screen.py:init_printer()] - Printer initialized
2023-10-29 16:17:18,192 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-10-29 16:17:18,193 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 16:17:18,340 [screen.py:_load_panel()] - Loading panel: main_menu
2023-10-29 16:17:18,594 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 16:17:18,611 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 16:17:18,627 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 16:17:18,642 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 16:17:18,716 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 16:21:19,063 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-10-29 16:21:19,064 [printer.py:change_state()] - Adding callback for state: printing
2023-10-29 16:21:19,083 [screen.py:_load_panel()] - Loading panel: job_status
2023-10-29 16:21:19,457 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-10-29 16:21:19,468 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-10-29 16:21:19,501 [job_status.py:update_file_metadata()] - Update Metadata. File: CE3MAX_lightlock.gcode Size: 625499
2023-10-29 16:21:19,502 [job_status.py:show_file_thumbnail()] - CE3MAX_lightlock.gcode
2023-10-29 16:21:19,503 [job_status.py:show_file_thumbnail()] - no pixbuf
2023-10-29 17:25:09,876 [printer.py:change_state()] - Changing state from 'printing' to 'disconnected'
2023-10-29 17:25:09,878 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 17:25:09,883 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 17:25:09,890 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:25:09,996 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:25:13,011 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:25:13,032 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:25:13,034 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: klipper primary_branch: main' contains an invalid value 'primary_branch:'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 17:25:13,037 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 klipper primary_branch:
 main' contains an invalid value 'primary_branch:
'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 17:25:13,066 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 17:25:13,068 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 17:25:13,091 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 17:25:13,127 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 17:25:13,131 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.249'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.463750, -0.100000, 0.260000, 0.607500\n-0.436250, -0.081250, 0.272500, 0.612500\n-0.450000, -0.093750, 0.258750, 0.621250\n-0.537500, -0.193750, 0.153750, 0.491250', 'x_count': '4', 'y_count': '4', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '87.80000000000001', 'max_x': '212.17000000000002', 'min_y': '77.3', 'max_y': '222.67'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.249, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.46375, -0.1, 0.26, 0.6075], [-0.43625, -0.08125, 0.2725, 0.6125], [-0.45, -0.09375, 0.25875, 0.62125], [-0.5375, -0.19375, 0.15375, 0.49125]], 'min_x': 87.80000000000001, 'max_x': 212.17000000000002, 'min_y': 77.3, 'max_y': 222.67, 'x_count': 4, 'y_count': 4, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 17:25:13,137 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 17:25:13,137 [printer.py:reinit()] - # Extruders: 1
2023-10-29 17:25:13,137 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 17:25:13,138 [printer.py:reinit()] - # Fans: 1
2023-10-29 17:25:13,138 [printer.py:reinit()] - # Output pins: 1
2023-10-29 17:25:13,138 [printer.py:reinit()] - # Leds: 1
2023-10-29 17:25:13,165 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 17:25:13,167 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 17:25:13,403 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 17:25:13,464 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:25:13,486 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 17:25:13,508 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 17:25:13,510 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 17:25:13,511 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 17:25:13,512 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 17:25:13,513 [screen.py:init_printer()] - Printer initialized
2023-10-29 17:25:13,514 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-10-29 17:25:13,515 [printer.py:change_state()] - Adding callback for state: startup
2023-10-29 17:25:14,870 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-10-29 17:25:14,870 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:25:14,877 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:25:15,034 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 17:25:15,048 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 17:25:15,061 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 17:25:15,075 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 17:25:15,146 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 17:26:16,608 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-10-29 17:26:16,608 [printer.py:change_state()] - Adding callback for state: printing
2023-10-29 17:26:16,622 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:26:16,877 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-10-29 17:26:16,889 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-10-29 17:26:16,907 [job_status.py:update_file_metadata()] - Update Metadata. File: CE3MAX_lightlock.gcode Size: 625499
2023-10-29 17:26:16,907 [job_status.py:show_file_thumbnail()] - CE3MAX_lightlock.gcode
2023-10-29 17:26:16,908 [job_status.py:show_file_thumbnail()] - no pixbuf
2023-10-29 17:33:02,436 [printer.py:change_state()] - Changing state from 'printing' to 'paused'
2023-10-29 17:33:02,437 [printer.py:change_state()] - Adding callback for state: paused
2023-10-29 17:33:02,447 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'paused'
2023-10-29 17:33:02,490 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:33:02,757 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-10-29 17:33:02,768 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'paused'
2023-10-29 17:33:02,785 [job_status.py:update_file_metadata()] - Update Metadata. File: CE3MAX_lightlock.gcode Size: 625499
2023-10-29 17:33:02,786 [job_status.py:show_file_thumbnail()] - CE3MAX_lightlock.gcode
2023-10-29 17:33:02,787 [job_status.py:show_file_thumbnail()] - no pixbuf
2023-10-29 17:33:02,798 [screen.py:_load_panel()] - Loading panel: extrude
2023-10-29 17:33:02,957 [screen.py:attach_panel()] - Current panel hierarchy: job_status > extrude
2023-10-29 17:33:02,961 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: SET_FILAMENT_SENSOR SENSOR=material_0 ENABLE=1
2023-10-29 17:33:02,965 [extrude.py:process_update()] - filament_switch_sensor material_0: {'filament_detected': True, 'enabled': True}
2023-10-29 17:33:09,968 [printer.py:change_state()] - Changing state from 'paused' to 'ready'
2023-10-29 17:33:09,970 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:33:15,019 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-10-29 17:33:15,020 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 17:33:15,024 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 17:33:15,029 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:33:15,184 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:33:18,014 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:33:18,037 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:33:18,039 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: klipper primary_branch: main' contains an invalid value 'primary_branch:'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 17:33:18,043 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 klipper primary_branch:
 main' contains an invalid value 'primary_branch:
'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 17:33:18,075 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 17:33:18,078 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 17:33:18,100 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 17:33:18,135 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 17:33:18,139 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.249'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.463750, -0.100000, 0.260000, 0.607500\n-0.436250, -0.081250, 0.272500, 0.612500\n-0.450000, -0.093750, 0.258750, 0.621250\n-0.537500, -0.193750, 0.153750, 0.491250', 'x_count': '4', 'y_count': '4', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '87.80000000000001', 'max_x': '212.17000000000002', 'min_y': '77.3', 'max_y': '222.67'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.249, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.46375, -0.1, 0.26, 0.6075], [-0.43625, -0.08125, 0.2725, 0.6125], [-0.45, -0.09375, 0.25875, 0.62125], [-0.5375, -0.19375, 0.15375, 0.49125]], 'min_x': 87.80000000000001, 'max_x': 212.17000000000002, 'min_y': 77.3, 'max_y': 222.67, 'x_count': 4, 'y_count': 4, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 17:33:18,144 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 17:33:18,145 [printer.py:reinit()] - # Extruders: 1
2023-10-29 17:33:18,145 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 17:33:18,146 [printer.py:reinit()] - # Fans: 1
2023-10-29 17:33:18,146 [printer.py:reinit()] - # Output pins: 1
2023-10-29 17:33:18,146 [printer.py:reinit()] - # Leds: 1
2023-10-29 17:33:18,173 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 17:33:18,177 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 17:33:18,410 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 17:33:18,472 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:33:18,487 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 17:33:18,510 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 17:33:18,513 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 17:33:18,514 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 17:33:18,515 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 17:33:18,516 [screen.py:init_printer()] - Printer initialized
2023-10-29 17:33:18,517 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-10-29 17:33:18,518 [printer.py:change_state()] - Adding callback for state: startup
2023-10-29 17:33:20,135 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-10-29 17:33:20,136 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:33:20,145 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:33:20,297 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 17:33:20,311 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 17:33:20,324 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 17:33:20,337 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 17:33:20,412 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 17:33:31,708 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-10-29 17:33:31,708 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 17:33:31,710 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 17:33:31,714 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:33:31,805 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:33:35,011 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:33:35,032 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:33:35,033 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: klipper primary_branch: main' contains an invalid value 'primary_branch:'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 17:33:35,036 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 klipper primary_branch:
 main' contains an invalid value 'primary_branch:
'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 17:33:35,065 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 17:33:35,067 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 17:33:35,089 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 17:33:35,125 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 17:33:35,130 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.249'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.463750, -0.100000, 0.260000, 0.607500\n-0.436250, -0.081250, 0.272500, 0.612500\n-0.450000, -0.093750, 0.258750, 0.621250\n-0.537500, -0.193750, 0.153750, 0.491250', 'x_count': '4', 'y_count': '4', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '87.80000000000001', 'max_x': '212.17000000000002', 'min_y': '77.3', 'max_y': '222.67'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.249, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.46375, -0.1, 0.26, 0.6075], [-0.43625, -0.08125, 0.2725, 0.6125], [-0.45, -0.09375, 0.25875, 0.62125], [-0.5375, -0.19375, 0.15375, 0.49125]], 'min_x': 87.80000000000001, 'max_x': 212.17000000000002, 'min_y': 77.3, 'max_y': 222.67, 'x_count': 4, 'y_count': 4, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 17:33:35,136 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 17:33:35,137 [printer.py:reinit()] - # Extruders: 1
2023-10-29 17:33:35,137 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 17:33:35,137 [printer.py:reinit()] - # Fans: 1
2023-10-29 17:33:35,138 [printer.py:reinit()] - # Output pins: 1
2023-10-29 17:33:35,138 [printer.py:reinit()] - # Leds: 1
2023-10-29 17:33:35,164 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 17:33:35,167 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 17:33:35,400 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 17:33:35,476 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:33:35,491 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 17:33:35,513 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 17:33:35,516 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 17:33:35,516 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 17:33:35,517 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 17:33:35,518 [screen.py:init_printer()] - Printer initialized
2023-10-29 17:33:35,519 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-10-29 17:33:35,520 [printer.py:change_state()] - Adding callback for state: startup
2023-10-29 17:33:36,874 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-10-29 17:33:36,875 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:33:36,882 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:33:37,033 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 17:33:37,047 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 17:33:37,060 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 17:33:37,074 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 17:33:37,148 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 17:33:53,740 [KlippyGtk.py:Dialog()] - Showing dialog Updating (width=804, height=480)
2023-10-29 17:34:18,792 [base_panel.py:process_update()] - Update complete
2023-10-29 17:34:18,840 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-10-29 17:34:18,841 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 17:34:18,843 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 17:34:18,847 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:34:18,952 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:34:22,018 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:34:22,041 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:34:22,043 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: klipper primary_branch: main' contains an invalid value 'primary_branch:'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 17:34:22,047 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 klipper primary_branch:
 main' contains an invalid value 'primary_branch:
'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 17:34:22,079 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 17:34:22,082 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 17:34:22,179 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 17:34:22,246 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 17:34:22,250 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.249'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.463750, -0.100000, 0.260000, 0.607500\n-0.436250, -0.081250, 0.272500, 0.612500\n-0.450000, -0.093750, 0.258750, 0.621250\n-0.537500, -0.193750, 0.153750, 0.491250', 'x_count': '4', 'y_count': '4', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '87.80000000000001', 'max_x': '212.17000000000002', 'min_y': '77.3', 'max_y': '222.67'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.249, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.46375, -0.1, 0.26, 0.6075], [-0.43625, -0.08125, 0.2725, 0.6125], [-0.45, -0.09375, 0.25875, 0.62125], [-0.5375, -0.19375, 0.15375, 0.49125]], 'min_x': 87.80000000000001, 'max_x': 212.17000000000002, 'min_y': 77.3, 'max_y': 222.67, 'x_count': 4, 'y_count': 4, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 17:34:22,257 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 17:34:22,257 [printer.py:reinit()] - # Extruders: 1
2023-10-29 17:34:22,258 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 17:34:22,258 [printer.py:reinit()] - # Fans: 1
2023-10-29 17:34:22,258 [printer.py:reinit()] - # Output pins: 1
2023-10-29 17:34:22,259 [printer.py:reinit()] - # Leds: 1
2023-10-29 17:34:22,285 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 17:34:22,289 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 17:34:22,523 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 17:34:22,596 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:34:22,611 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 17:34:22,632 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 17:34:22,634 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 17:34:22,635 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 17:34:22,635 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 17:34:22,637 [screen.py:init_printer()] - Printer initialized
2023-10-29 17:34:22,638 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-10-29 17:34:22,639 [printer.py:change_state()] - Adding callback for state: startup
2023-10-29 17:34:24,503 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-10-29 17:34:24,503 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:34:24,509 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:34:24,660 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 17:34:24,675 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 17:34:24,688 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 17:34:24,701 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 17:34:24,776 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 17:38:23,908 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-10-29 17:38:23,909 [printer.py:change_state()] - Adding callback for state: printing
2023-10-29 17:38:23,926 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:38:24,198 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-10-29 17:38:24,210 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-10-29 17:38:24,229 [job_status.py:update_file_metadata()] - Update Metadata. File: pressure_advance_test_PLA_4m59s.gcode Size: 46835
2023-10-29 17:38:24,239 [job_status.py:show_file_thumbnail()] - pressure_advance_test_PLA_4m59s.gcode
2023-10-29 17:38:24,294 [KlippyWebsocket.py:get_file_dir()] - Sending server.files.directory
2023-10-29 17:39:01,746 [base_panel.py:finish_updating()] - Finishing update
2023-10-29 17:39:01,754 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-10-29 17:39:01,755 [screen.py:_menu_go_back()] - #### Menu go home
2023-10-29 17:39:01,786 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-10-29 17:39:01,809 [job_status.py:update_file_metadata()] - Update Metadata. File: pressure_advance_test_PLA_4m59s.gcode Size: 46835
2023-10-29 17:39:01,819 [job_status.py:show_file_thumbnail()] - pressure_advance_test_PLA_4m59s.gcode
2023-10-29 17:40:45,421 [screen.py:_load_panel()] - Loading panel: fine_tune
2023-10-29 17:40:45,618 [screen.py:attach_panel()] - Current panel hierarchy: job_status > fine_tune
2023-10-29 17:40:47,283 [fine_tune.py:change_percent_delta()] - ### Delta 0.01
2023-10-29 17:40:59,040 [screen.py:_send_action()] - printer.gcode.script: {'script': 'SET_GCODE_OFFSET Z_ADJUST=+0.01 MOVE=1'}
2023-10-29 17:48:05,064 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-10-29 17:48:05,065 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:53:22,074 [screen.py:_menu_go_back()] - #### Menu go back
2023-10-29 17:53:22,145 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-10-29 17:53:22,162 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-10-29 17:53:22,170 [job_status.py:update_file_metadata()] - Update Metadata. File: pressure_advance_test_PLA_4m59s.gcode Size: 46835
2023-10-29 17:53:22,180 [job_status.py:show_file_thumbnail()] - pressure_advance_test_PLA_4m59s.gcode
2023-10-29 17:53:41,875 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-10-29 17:53:41,876 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 17:53:41,877 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 17:53:41,882 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:53:41,973 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:53:45,015 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:53:45,035 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:53:45,038 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: klipper primary_branch: main' contains an invalid value 'primary_branch:'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 17:53:45,041 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 klipper primary_branch:
 main' contains an invalid value 'primary_branch:
'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 17:53:45,071 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 17:53:45,073 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 17:53:45,096 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 17:53:45,134 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 17:53:45,137 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.244'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.011250, -0.016250, -0.030000, -0.028750, -0.038750, -0.002500\n-0.010000, -0.040000, -0.056250, -0.056250, -0.060000, -0.027500\n0.060000, 0.021250, -0.007500, -0.026250, -0.058750, -0.047500\n0.050000, 0.031250, -0.001250, -0.016250, -0.043750, -0.031250\n0.060000, 0.043750, 0.027500, 0.005000, -0.035000, -0.030000\n0.070000, 0.045000, 0.026250, 0.002500, -0.041250, -0.025000', 'x_count': '6', 'y_count': '6', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '20.0', 'max_x': '250.0', 'min_y': '35.0', 'max_y': '280.0'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.244, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.01125, -0.01625, -0.03, -0.02875, -0.03875, -0.0025], [-0.01, -0.04, -0.05625, -0.05625, -0.06, -0.0275], [0.06, 0.02125, -0.0075, -0.02625, -0.05875, -0.0475], [0.05, 0.03125, -0.00125, -0.01625, -0.04375, -0.03125], [0.06, 0.04375, 0.0275, 0.005, -0.035, -0.03], [0.07, 0.045, 0.02625, 0.0025, -0.04125, -0.025]], 'min_x': 20.0, 'max_x': 250.0, 'min_y': 35.0, 'max_y': 280.0, 'x_count': 6, 'y_count': 6, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 17:53:45,144 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 17:53:45,144 [printer.py:reinit()] - # Extruders: 1
2023-10-29 17:53:45,145 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 17:53:45,145 [printer.py:reinit()] - # Fans: 1
2023-10-29 17:53:45,145 [printer.py:reinit()] - # Output pins: 1
2023-10-29 17:53:45,145 [printer.py:reinit()] - # Leds: 1
2023-10-29 17:53:45,173 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 17:53:45,177 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 17:53:45,402 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 17:53:45,475 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:53:45,485 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 17:53:45,507 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 17:53:45,510 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 17:53:45,511 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 17:53:45,511 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 17:53:45,512 [screen.py:init_printer()] - Printer initialized
2023-10-29 17:53:45,514 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-10-29 17:53:45,514 [printer.py:change_state()] - Adding callback for state: startup
2023-10-29 17:53:46,877 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-10-29 17:53:46,878 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:53:46,883 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:53:47,053 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 17:53:47,072 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 17:53:47,088 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 17:53:47,107 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 17:53:47,201 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 17:55:11,346 [KlippyWebsocket.py:on_close()] - Server Shutdown
2023-10-29 17:55:11,347 [KlippyWebsocket.py:on_close()] - Moonraker Websocket Closed
2023-10-29 17:55:11,357 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:55:11,488 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:55:11,506 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-10-29 17:55:11,508 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:55:11,598 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 17:55:11,617 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-10-29 17:55:11,629 [KlippyRest.py:_do_request()] - host=127.0.0.1, port=7125>>Max retries exceeded with url>>Failed to establish a new connection>>[Errno 111] Connection refused
2023-10-29 17:55:21,997 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-10-29 17:55:22,029 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:55:22,062 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-10-29 17:55:22,066 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-10-29 17:55:22,088 [_logging.py:info()] - Websocket connected
2023-10-29 17:55:22,089 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-10-29 17:55:22,121 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:55:22,160 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 17:55:22,163 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'ready', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 17:55:22,167 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 17:55:22,197 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 17:55:22,199 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 17:55:22,222 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 17:55:22,284 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 17:55:22,288 [screen.py:init_printer()] - {'configfile': {'config': {'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.244'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.011250, -0.016250, -0.030000, -0.028750, -0.038750, -0.002500\n-0.010000, -0.040000, -0.056250, -0.056250, -0.060000, -0.027500\n0.060000, 0.021250, -0.007500, -0.026250, -0.058750, -0.047500\n0.050000, 0.031250, -0.001250, -0.016250, -0.043750, -0.031250\n0.060000, 0.043750, 0.027500, 0.005000, -0.035000, -0.030000\n0.070000, 0.045000, 0.026250, 0.002500, -0.041250, -0.025000', 'x_count': '6', 'y_count': '6', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '20.0', 'max_x': '250.0', 'min_y': '35.0', 'max_y': '280.0'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.244, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.01125, -0.01625, -0.03, -0.02875, -0.03875, -0.0025], [-0.01, -0.04, -0.05625, -0.05625, -0.06, -0.0275], [0.06, 0.02125, -0.0075, -0.02625, -0.05875, -0.0475], [0.05, 0.03125, -0.00125, -0.01625, -0.04375, -0.03125], [0.06, 0.04375, 0.0275, 0.005, -0.035, -0.03], [0.07, 0.045, 0.02625, 0.0025, -0.04125, -0.025]], 'min_x': 20.0, 'max_x': 250.0, 'min_y': 35.0, 'max_y': 280.0, 'x_count': 6, 'y_count': 6, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 17:55:22,295 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 17:55:22,296 [printer.py:reinit()] - # Extruders: 1
2023-10-29 17:55:22,296 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 17:55:22,296 [printer.py:reinit()] - # Fans: 1
2023-10-29 17:55:22,297 [printer.py:reinit()] - # Output pins: 1
2023-10-29 17:55:22,297 [printer.py:reinit()] - # Leds: 1
2023-10-29 17:55:22,323 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 17:55:22,326 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 17:55:22,560 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 17:55:22,598 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 17:55:22,649 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 17:55:22,677 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 17:55:22,679 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 17:55:22,680 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 17:55:22,681 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 17:55:22,682 [screen.py:init_printer()] - Printer initialized
2023-10-29 17:55:22,683 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-10-29 17:55:22,684 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 17:55:22,798 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 17:55:22,948 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 17:55:22,963 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 17:55:22,975 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 17:55:22,989 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 17:55:23,061 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 18:00:25,000 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-10-29 18:00:25,001 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 18:00:25,002 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 18:00:25,006 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 18:00:25,176 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 18:00:29,011 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:00:29,031 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:00:29,033 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 18:00:29,036 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 18:00:29,061 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 18:00:29,063 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 18:00:29,089 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-10-29 18:00:29,124 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-10-29 18:00:29,128 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'display_status': {}, 'pause_resume': {}, 'gcode_macro START_PRINT': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0'}, 'gcode_macro END_PRINT': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84'}, 'gcode_macro PIDtuneHOTEND': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}'}, 'gcode_macro PIDtuneBED': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'exclude_object': {}, 'stepper_x': {'step_pin': 'PA14', 'dir_pin': '!PA10', 'enable_pin': '!PA13', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PC4', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_y': {'step_pin': 'PC8', 'dir_pin': '!PA15', 'enable_pin': '!PC14', 'microsteps': '16', 'rotation_distance': '40', 'endstop_pin': '^PB0', 'position_endstop': '0', 'position_max': '310', 'homing_speed': '50'}, 'stepper_z': {'step_pin': 'PD2', 'dir_pin': '!PD4', 'enable_pin': '!PD3', 'microsteps': '16', 'rotation_distance': '8', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '320', 'position_min': '-8'}, 'extruder': {'step_pin': 'PD5', 'dir_pin': 'PD6', 'enable_pin': '!PB3', 'microsteps': '16', 'gear_ratio': '42:12', 'rotation_distance': '26.359', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'heater_pin': 'PB11', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '300', 'control': 'pid', 'pid_kp': '25.614', 'pid_ki': '0.970', 'pid_kd': '169.052'}, 'bltouch': {'sensor_pin': 'PA6', 'control_pin': 'PA7', 'x_offset': '-45.0', 'y_offset': '0', 'pin_up_touch_mode_reports_triggered': 'True', 'probe_with_touch_mode': 'true', 'stow_on_each_sample': 'false', 'speed': '10', 'samples': '2', 'sample_retract_dist': '2.5', 'lift_speed': '40', 'samples_tolerance_retries': '3', 'z_offset': '3.244'}, 'safe_z_home': {'home_xy_position': '185,160', 'speed': '250', 'z_hop': '10', 'z_hop_speed': '5'}, 'bed_mesh': {'speed': '120', 'mesh_min': '20, 35', 'mesh_max': '250, 280', 'probe_count': '6,6', 'fade_start': '1', 'fade_end': '10', 'fade_target': '0', 'algorithm': 'bicubic'}, 'screws_tilt_adjust': {'screw1': '73, 40', 'screw1_name': 'front left screw', 'screw2': '310, 40', 'screw2_name': 'front right screw', 'screw3': '310, 280', 'screw3_name': 'rear right screw', 'screw4': '73, 280', 'screw4_name': 'rear left screw', 'horizontal_move_z': '10.', 'screw_thread': 'CW-M4'}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'min_temp': '10', 'max_temp': '100'}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5'}, 'heater_bed': {'heater_pin': 'PB2', 'sensor_type': 'EPCOS 100K B57560G104F', 'sensor_pin': 'PA3', 'control': 'watermark', 'min_temp': '0', 'max_temp': '130'}, 'fan': {'pin': 'PA8'}, 'output_pin PS_ON': {'pin': 'PB9'}, 'neopixel my_neopixel': {'pin': 'PC7'}, 'adxl345': {'cs_pin': 'PC15', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12', 'spi_software_sclk_pin': 'PC10'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '150, 100, 20'}, 'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00'}, 'printer': {'kinematics': 'cartesian', 'max_velocity': '200', 'max_accel': '2000', 'max_z_velocity': '5', 'max_z_accel': '100'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'run_current': '0.650', 'stealthchop_threshold': '999999'}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'run_current': '0.800', 'stealthchop_threshold': '999999'}, 'board_pins': {'aliases': '\n\nEXP1_1=PC1, EXP1_3=PC3, EXP1_5=PC0, EXP1_7=PA2, EXP1_9=<GND>,\nEXP1_2=PC2,  EXP1_4=<RST>, EXP1_6=PA0, EXP1_8=PA1, EXP1_10=<5V>'}, 'bed_mesh default': {'version': '1', 'points': '\n-0.011250, -0.016250, -0.030000, -0.028750, -0.038750, -0.002500\n-0.010000, -0.040000, -0.056250, -0.056250, -0.060000, -0.027500\n0.060000, 0.021250, -0.007500, -0.026250, -0.058750, -0.047500\n0.050000, 0.031250, -0.001250, -0.016250, -0.043750, -0.031250\n0.060000, 0.043750, 0.027500, 0.005000, -0.035000, -0.030000\n0.070000, 0.045000, 0.026250, 0.002500, -0.041250, -0.025000', 'x_count': '6', 'y_count': '6', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '20.0', 'max_x': '250.0', 'min_y': '35.0', 'max_y': '280.0'}}, 'settings': {'mcu': {'serial': '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_3F0049000C504B5735313920-if00', 'baud': 250000, 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'gcode_macro start_print': {'gcode': '\n{% set BED_TEMP = params.BED_TEMP|default(60)|float %}\n{% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}\n\nM140 S{BED_TEMP}\n\n\nG90\n\n\n\nG28\nBED_MESH_CALIBRATE\n\n\n\n\n\n\nM190 S{BED_TEMP}\n\nM109 S205\nG1 Z2.0 F3000\nG1 X0.1 Y30 Z0.3 F5000.0\nG1 X0.1 Y200.0 Z0.3 F1500.0 E15\nG1 X0.4 Y200.0 Z0.3 F5000.0\nG1 X0.4 Y30 Z0.3 F1500.0 E30\nG92 E0\nG1 Z2.0 F3000\nG1 X5 Y25 Z0.3 F5000.0', 'description': 'G-Code macro'}, 'gcode_macro end_print': {'gcode': '\n\nM140 S0\nM104 S0\nM106 S0\n\nG91\nG1 X-2 Y-2 E-3 F300\n\nG1 Z10 F3000\nG90\n\nM84', 'description': 'G-Code macro'}, 'gcode_macro pidtunehotend': {'gcode': '\n{% set TEMP = params.TEMP|default(200)|float %}\nPID_CALIBRATE HEATER=extruder TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro pidtunebed': {'gcode': '\n{% set TEMP = params.TEMP|default(60)|float %}\nPID_CALIBRATE HEATER=heater_bed TARGET={TEMP}', 'description': 'G-Code macro'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'bltouch': {'z_offset': 3.244, 'stow_on_each_sample': False, 'probe_with_touch_mode': True, 'control_pin': 'PA7', 'sensor_pin': 'PA6', 'pin_up_reports_not_triggered': True, 'pin_up_touch_mode_reports_triggered': True, 'pin_move_time': 0.68, 'speed': 10.0, 'lift_speed': 40.0, 'x_offset': -45.0, 'y_offset': 0.0, 'samples': 2, 'sample_retract_dist': 2.5, 'samples_result': 'average', 'samples_tolerance': 0.1, 'samples_tolerance_retries': 3}, 'safe_z_home': {'home_xy_position': [185.0, 160.0], 'z_hop': 10.0, 'z_hop_speed': 5.0, 'speed': 250.0, 'move_to_previous': False}, 'bed_mesh': {'probe_count': [6, 6], 'mesh_min': [20.0, 35.0], 'mesh_max': [250.0, 280.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 120.0, 'fade_start': 1.0, 'fade_end': 10.0, 'fade_target': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.01125, -0.01625, -0.03, -0.02875, -0.03875, -0.0025], [-0.01, -0.04, -0.05625, -0.05625, -0.06, -0.0275], [0.06, 0.02125, -0.0075, -0.02625, -0.05875, -0.0475], [0.05, 0.03125, -0.00125, -0.01625, -0.04375, -0.03125], [0.06, 0.04375, 0.0275, 0.005, -0.035, -0.03], [0.07, 0.045, 0.02625, 0.0025, -0.04125, -0.025]], 'min_x': 20.0, 'max_x': 250.0, 'min_y': 35.0, 'max_y': 280.0, 'x_count': 6, 'y_count': 6, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'screws_tilt_adjust': {'screw1': [73.0, 40.0], 'screw1_name': 'front left screw', 'screw2': [310.0, 40.0], 'screw2_name': 'front right screw', 'screw3': [310.0, 280.0], 'screw3_name': 'rear right screw', 'screw4': [73.0, 280.0], 'screw4_name': 'rear left screw', 'screw_thread': 'CW-M4', 'horizontal_move_z': 10.0, 'speed': 50.0}, 'temperature_sensor raspberry_pi': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': 10.0, 'max_temp': 100.0}, 'filament_switch_sensor material_0': {'switch_pin': 'PC5', 'pause_on_runout': True, 'runout_gcode': '', 'pause_delay': 0.5, 'event_delay': 3.0}, 'heater_bed': {'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA3', 'min_temp': 0.0, 'max_temp': 130.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'watermark', 'max_delta': 2.0, 'heater_pin': 'PB2', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.1, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'PA8'}, 'output_pin ps_on': {'pwm': False, 'pin': 'PB9', 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'neopixel my_neopixel': {'pin': 'PC7', 'chain_count': 1, 'color_order': ['GRB'], 'initial_red': 0.0, 'initial_green': 0.0, 'initial_blue': 0.0, 'initial_white': 0.0}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'PC15', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'PC10', 'spi_software_miso_pin': 'PC11', 'spi_software_mosi_pin': 'PC12'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[150.0, 100.0, 20.0]], 'accel_chip': 'adxl345'}, 'tmc2209 stepper_x': {'uart_pin': 'PB8', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 16, 'step_pin': 'PA14', 'dir_pin': '!PA10', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PA13', 'endstop_pin': '^PC4', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_y': {'uart_pin': 'PC9', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 16, 'step_pin': 'PC8', 'dir_pin': '!PA15', 'rotation_distance': 40.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PC14', 'endstop_pin': '^PB0', 'position_endstop': 0.0, 'position_min': 0.0, 'position_max': 310.0, 'homing_speed': 50.0, 'second_homing_speed': 25.0, 'homing_retract_speed': 50.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.65, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 16, 'step_pin': 'PD2', 'dir_pin': '!PD4', 'rotation_distance': 8.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD3', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -8.0, 'position_max': 320.0, 'homing_speed': 5.0, 'second_homing_speed': 2.5, 'homing_retract_speed': 5.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': False}, 'tmc2209 extruder': {'uart_pin': 'PD1', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 999999.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'EPCOS 100K B57560G104F', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 300.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 25.614, 'pid_ki': 0.97, 'pid_kd': 169.052, 'heater_pin': 'PB11', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 0.6400000000000001, 'max_extrude_only_velocity': 53.21621607382886, 'max_extrude_only_accel': 532.1621607382885, 'max_extrude_only_distance': 50.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'PD5', 'pressure_advance': 0.0, 'pressure_advance_smooth_time': 0.04, 'dir_pin': 'PD6', 'rotation_distance': 26.359, 'full_steps_per_rotation': 200, 'gear_ratio': [[42.0, 12.0]], 'enable_pin': '!PB3'}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PC1'], ['EXP1_3', 'PC3'], ['EXP1_5', 'PC0'], ['EXP1_7', 'PA2'], ['EXP1_9', '<GND>'], ['EXP1_2', 'PC2'], ['EXP1_4', '<RST>'], ['EXP1_6', 'PA0'], ['EXP1_8', 'PA1'], ['EXP1_10', '<5V>']]}, 'printer': {'max_velocity': 200.0, 'max_accel': 2000.0, 'max_accel_to_decel': 1000.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'cartesian', 'max_z_velocity': 5.0, 'max_z_accel': 100.0}, 'force_move': {'enable_force_move': False}, 'idle_timeout': {'timeout': 600.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-10-29 18:00:29,134 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-10-29 18:00:29,134 [printer.py:reinit()] - # Extruders: 1
2023-10-29 18:00:29,134 [printer.py:reinit()] - # Temperature devices: 2
2023-10-29 18:00:29,135 [printer.py:reinit()] - # Fans: 1
2023-10-29 18:00:29,135 [printer.py:reinit()] - # Output pins: 1
2023-10-29 18:00:29,135 [printer.py:reinit()] - # Leds: 1
2023-10-29 18:00:29,162 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-10-29 18:00:29,165 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-10-29 18:00:29,404 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor raspberry_pi&fan&filament_switch_sensor material_0&output_pin PS_ON&neopixel my_neopixel
2023-10-29 18:00:29,462 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-10-29 18:00:29,486 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor raspberry_pi', 'heater_bed', 'extruder']
2023-10-29 18:00:29,511 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-10-29 18:00:29,514 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-10-29 18:00:29,515 [files.py:initialize()] - Gcodes path: /home/orangepi/printer_data/gcodes
2023-10-29 18:00:29,516 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-10-29 18:00:29,517 [screen.py:init_printer()] - Printer initialized
2023-10-29 18:00:29,518 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-10-29 18:00:29,519 [printer.py:change_state()] - Adding callback for state: startup
2023-10-29 18:00:30,121 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-10-29 18:00:30,121 [printer.py:change_state()] - Adding callback for state: ready
2023-10-29 18:00:30,128 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 18:00:30,283 [main_menu.py:__init__()] - ### Making MainMenu
2023-10-29 18:00:30,297 [main_menu.py:add_device()] - Adding device: extruder
2023-10-29 18:00:30,311 [main_menu.py:add_device()] - Adding device: heater_bed
2023-10-29 18:00:30,324 [main_menu.py:add_device()] - Adding device: temperature_sensor raspberry_pi
2023-10-29 18:00:30,397 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-10-29 18:33:20,748 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-10-29 18:33:20,749 [printer.py:change_state()] - Adding callback for state: disconnected
2023-10-29 18:33:20,750 [screen.py:state_disconnected()] - ### Going to disconnected
2023-10-29 18:33:20,754 [screen.py:show_panel()] - Reinitializing panel
2023-10-29 18:33:20,846 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-10-29 18:33:24,040 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:24,086 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:24,089 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 18:33:24,097 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 18:33:24,159 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 18:33:24,162 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 18:33:24,163 [screen.py:init_printer()] - Klipper not connected
2023-10-29 18:33:27,036 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:27,056 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:27,059 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 18:33:27,063 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 18:33:27,087 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 18:33:27,090 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 18:33:27,090 [screen.py:init_printer()] - Klipper not connected
2023-10-29 18:33:30,039 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:30,079 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:30,081 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 18:33:30,086 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 18:33:30,110 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 18:33:30,112 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 18:33:30,112 [screen.py:init_printer()] - Klipper not connected
2023-10-29 18:33:33,046 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:33,091 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:33,094 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 18:33:33,099 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 18:33:33,123 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 18:33:33,125 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 18:33:33,126 [screen.py:init_printer()] - Klipper not connected
2023-10-29 18:33:36,039 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:36,085 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-10-29 18:33:36,090 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': ["[update_manager Klipper-Adaptive-Meshing-Purging]: Option 'managed_services: Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices: ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']"], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-10-29 18:33:36,100 [screen.py:show_popup_message()] - warning: 
Moonraker warnings:
[update_manager Klipper-Adaptive-Meshing-Purging]:
 Option 'managed_services:
 Klipper' contains an invalid value 'Klipper'.  All values must be one of the following choices:
 ['Klipper-Adaptive-Meshing-Purging', 'klipper', 'moonraker']

2023-10-29 18:33:36,130 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-10-29 18:33:36,131 [printer.py:configure_cameras()] - Cameras: []
2023-10-29 18:33:36,132 [screen.py:init_printer()] - Klipper not connected
2023-10-29 18:33:45,723 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 18:39:27,911 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 18:45:41,922 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 18:47:31,099 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 18:48:36,740 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 18:49:14,097 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 18:50:10,250 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 18:50:31,222 [screen.py:show_popup_message()] - error: // Author identity unknown
// 
// *** Please tell me who you are.
// 
// Run
// 
// git config --global user.email "you@example.com"
// git config --global user.name "Your Name"
// 
// to set your account's default identity.
// Omit --global to set the identity only in this repository.
// 
// fatal: unable to auto-detect email address (got 'orangepi@orangepicm4.(none)')
2023-10-29 18:53:22,015 [screen.py:show_screensaver()] - Showing Screensaver
2023-10-29 19:01:34,707 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 19:01:50,458 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 19:02:13,819 [screen.py:close_screensaver()] - Closing Screensaver
2023-10-29 19:02:13,840 [screen.py:wake_screen()] - Screen wake up
2023-10-29 19:02:14,179 [screen.py:show_popup_message()] - error: // Author identity unknown
// 
// *** Please tell me who you are.
// 
// Run
// 
// git config --global user.email "you@example.com"
// git config --global user.name "Your Name"
// 
// to set your account's default identity.
// Omit --global to set the identity only in this repository.
// 
// fatal: unable to auto-detect email address (got 'orangepi@orangepicm4.(none)')
2023-10-29 19:09:56,207 [screen.py:show_popup_message()] - error: // Author identity unknown
// 
// *** Please tell me who you are.
// 
// Run
// 
// git config --global user.email "you@example.com"
// git config --global user.name "Your Name"
// 
// to set your account's default identity.
// Omit --global to set the identity only in this repository.
// 
// fatal: unable to auto-detect email address (got 'orangepi@orangepicm4.(none)')
2023-10-29 19:11:08,429 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 19:11:38,646 [screen.py:show_popup_message()] - error: // Author identity unknown
// 
// *** Please tell me who you are.
// 
// Run
// 
// git config --global user.email "you@example.com"
// git config --global user.name "Your Name"
// 
// to set your account's default identity.
// Omit --global to set the identity only in this repository.
// 
// fatal: unable to auto-detect email address (got 'orangepi@orangepicm4.(none)')
2023-10-29 19:16:40,543 [screen.py:_websocket_callback()] - Still not initialized
2023-10-29 19:16:54,699 [screen.py:_websocket_callback()] - Still not initialized
